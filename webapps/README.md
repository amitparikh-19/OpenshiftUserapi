<h1>Grey Matter</h1>
Simple AJS Boilerplate with SASS support and Grunt watch/build tasks

<h3> Features </h3>

- Grunt watch, build and local server tasks

- Componentized & Modularized UI

- Responsive navigation

- Generic $http wrapper to handle calls

- Clean folder structure

- SASS support

- Minified & Annotated build files


<h2>Project Structure</h2>

Below is our project structure for the UI:

<p>
  <img src="https://github.com/kirmich/mustang/blob/%23200/webapps/resources/images/structure.png" width="350"/>
</p>

<b>/layout</b> directory will be holding our portal layout template which will include our Side Navigation bar and Top fixed bar, all main entity/feature modules view will be injected here.

<b>/resources</b> will be holding our sass style sheets, fonts and images required throughout the project

<b>/index.html</b> will be our main application template page which will be outlet to our angular app additional we would be importing all the external libs and our projects js files.

<b>/build</b> will be holding our final build files i.e annotated, complied sass files, minified files 


<h2>Modules </h2>
The UI project is divided into several sub-modules, there is one '<b>parent</b>' module ( main.js ) and several '<b>child</b>' modules ( features -> Entities ) under <entity> directories. The main.js is holding our all project dependencies injection and main routes to other children modules, this way we will be simply delegating the child controller and routes like /create, /update etc to their respective modules under <entity> directory and controllers under <entity>/<operation> who would be handing CRUD operations. 

If we are adding any new module into the application, we need to follow below steps :

- Under modules directory, create a separate folder which should contain your index file and a module js file with name as <entity>-module.js

- Your <b><entity>-module.js </b>( module file ) should contain module routes to child controllers and service URLS that are to be used by child controllers.

- For any operation that needs to be added for that module will be in done in separate folder which will contain its html template and controller js.

- Add the module defination and prime route to modules’s index in main.js

<b>NOTE </b>: Make sure the new module which we are adding is under /modules directory so that grunt is able to pick its js files, placing modules into any other place can cause angular to throw back some errors.

below URLs to be followed  for child routes for any CRUD operation on an entity :
```
<entity-name>/                  - List for a entity

<entity-name>/{id}              - Details of an entity

<entity-name>/create            - Create entity

<entity-name>/update/{id}       - Update entity
```

<h2>Components </h2>
The components that we are using in our project are situated at /components directory.
Any new component that is to be added should follow these rules :

- Create the individual component folder under with name as <component-name>-widget.

- That folder should contain 2 files - one html template and other is component js.

- The component js file should extend the exiting component module i.e ‘commonComponents’.


<h2>Directives</h2>
This Directory will be holding commonly used DOM markers thorough the user input forms. Any new directive added must extend the existing angular module - formDirective

<h2>i18n Translation</h2>
I18n translation json file for language will be situated under /i18n, this will basically contain 2 json files for a language.

- <b>common-rb-xx.json</b> - which will contain translation strings ( key - value ) which will be common to all the modules.

- <b>rb-xx.json</b> - This is autogenerated file which made from compiling all the modules rbs (should not commit this file in case, already added to git ignore) 


Since we are following a modular approach with UI so all our modules will have there own rb files which will minimise the conflicts, when the UI is built with grunt it will concat all the rbs files from different modules and create a single file for i18n module to use.

<h2>Interceptors </h2>
The /interceptors will be holding our HTTP call interceptor and we will be injecting appropriate authentication headers and token here.

<h2>HTTP Service </h2>
All the outgoing Http calls from client to REST will be handled by generic http service which needs to be injected in our controller, it supports following methods :

- create
This call will create an entity object, It will accept 4 parameters :
```
@param entityObj  : the obj which needs to be created

@param serviceUrl : urlObj which will have the url list for the entity. 

@param successFn : the call back success function

@param errorFn :  the call back failure function
```

- read
This call will fetch an entity object by id, again It will accept 4 parameters :
```
@param entityObj :  the obj should have a field as ‘id’ whose details are needed to be fetched

@param serviceUrl : urlObj which will have the url list for the entity. 

@param successFn :  the call back success function

@param errorFn : the call back failure function
```

- readAll
This call will fetch the list ( non pageable ), again It will accept 4 parameters :
```
@param entityObj : the obj to filter to the result

@param serviceUrl : urlObj which will have the url list for the entity. 

@param successFn : the call back success function

@param errorFn : the call back failure function
```

- readAllPageable	
This call will fetch the list ( pageable ), again It will accept 4 parameters :
```
@param entityObj : the obj to filter to the result

@param serviceUrl : urlObj which will have the url list for the entity. 

@param successFn:  the call back success function

@param errorFn : the call back failure function
```

- update
This call will update an existing entity object, again It will accept 4 parameters :
```
 @param entityObj  : the object params that needs to be updated
 
 @param serviceUrl : urlObj which will have the url list for the entity. 
 
 @param successFn :  the call back success function
 
 @param errorFn : the call back failure function	
```

- deleteEntity
This call will delete an existing entity object , again It will accept 4 parameters :
```
 @param entityObj : the obj will have id whose record needs to be deleted 
 
 @param serviceUrl : urlObj which will have the url list for the entity. 
 
 @param successFn :  the call back success function
 
 @param errorFn : the call back failure function
```

- doOperation
This call is there for performing any other call apart from CRUD operation ; like performing some txn or hitting any any other service which have some kind of custom URL.
It accepts 5 parameters :

```
@param entityObj 

@param httpMethod : ( POST | PUT | PATCH | GET | DELETE ) 

@serviceUrl : The url that needs to be hit

@param successFn : the call back success function

@param errorFn : the call back failure function

```

<h2>Bower Components</h2>
The following packages are always installed by the app generator:

- Angular
- jQuery
- Bootstrap
- Angular-boostrap
- Angular-ui-router
- Angular-translate
- Angular-translate-loader-static-files
- Angular-sanitize
- Loadash

All these libraries will be installed when ui is built. Any new additions to libraries must be added in bower.json and should be reviewed by all the members.

Libraries in bower.json will be installed in /libs directory.

<h2>UI Coding Guidelines</h2>
For any kind of CRUD operations we need to follow these coding guidelines - 
<a href='https://github.com/kirmich/mustang/wiki/Coding-Guidelines'>UI Coding Guidelines</a>

<h2>Building UI</h2>

Go to ui project directory and execute the following commands :
```
bower install

npm install
```

~if you are doing development in portal 

Use following command for building ui -
```
grunt dev
```
above command will continuously watch for new changes and update the /build folder ~It will concurrently check for any changes made to the UI files (*.js / *.html / *.sass ) 

For simply running the build one time just execute :
```
grunt build
```
<b>NOTE: </b> Behind the curtains it will just concat all the annotated js files and minify it under build folder, moreover it will also compile the sass files to css files. When running your HTTP server make sure you point the UI path to /build folder.

